package com.example.proximitytest.ui

import android.annotation.SuppressLint
import android.graphics.Color
import android.os.Bundle
import android.util.Log
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.ViewModelProvider
import com.example.proximitytest.R
import com.example.proximitytest.data.Aqi
import com.example.proximitytest.viewmodel.AqiViewModel
import kotlinx.android.synthetic.main.activity_main.*
import lecho.lib.hellocharts.model.Axis
import lecho.lib.hellocharts.model.Line
import lecho.lib.hellocharts.model.LineChartData
import lecho.lib.hellocharts.model.PointValue
import lecho.lib.hellocharts.view.LineChartView
import okhttp3.*
import org.json.JSONException
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.ArrayList


class   ChartActivity : AppCompatActivity(){

    private lateinit var aqcinChart: LineChartView
    private var client: OkHttpClient? = null
    private lateinit var viewModel: AqiViewModel
    lateinit var city:String

    private inner class EchoWebSocketListener : WebSocketListener() {
        override fun onMessage(webSocket: WebSocket, text: String) {
            try {
                output(text)
                Log.e("AQI",text)
            } catch (e: JSONException) {
                e.printStackTrace()
            }
        }

        override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
            webSocket.close(NORMAL_CLOSURE_STATUS, null)
            try {
                output("Closing : $code / $reason")
            } catch (e: JSONException) {
                e.printStackTrace()
            }
        }

        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
            try {
                output("Error : " + t.message)
            } catch (e: JSONException) {
                e.printStackTrace()
            }
        }

    }

    private fun output(s: String) {

        val forecast: ArrayList<Aqi>? = viewModel.output(s)

        // Dates formatter

        // Dates formatter
        @SuppressLint("SimpleDateFormat") val fullFormatter = SimpleDateFormat("yyyy-MM-dd")
        @SuppressLint("SimpleDateFormat") val dayFormatter = SimpleDateFormat("dd")
        @SuppressLint("SimpleDateFormat") val monthFormatter = SimpleDateFormat("MM")

        val values: MutableList<PointValue> = ArrayList()
        val xAxisValues1: MutableList<Float> = ArrayList()
        val xAxisValues2: MutableList<String> = ArrayList()

        var index = 0
        var maxVal = 0f
        var day = "--"
        if (forecast != null) {
            for (aqcin : Aqi in forecast) {
                    values.add(PointValue(index.toFloat(), aqcin.aqi.toFloat()))
                    xAxisValues1.add(index.toFloat())

                    // Display x axis values
                    try {

                        val c = Calendar.getInstance().time
                        val df = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                        val formattedDate = df.format(c)

                        val date = fullFormatter.parse(formattedDate)
                        val dayName = dayFormatter.format(date)
                        val month = monthFormatter.format(date)
                        day = "$dayName/$month"
                    } catch (e: ParseException) {
                        e.printStackTrace()
                    }
                    xAxisValues2.add(day)
                    // Searching max value
                    if (maxVal < aqcin.aqi.toFloat()) maxVal = aqcin.aqi.toFloat()
                    index++
            }
        }
        Log.e("values",values.toString())
        val line = Line(values).setColor(Color.RED).setCubic(true)
        val lines: MutableList<Line> = ArrayList()
        lines.add(line)

        val xAxis = Axis.generateAxisFromCollection(xAxisValues1, xAxisValues2)
        xAxis.isAutoGenerated = false
        xAxis.textSize = 8
        xAxis.setHasLines(true)

        val yAxis = Axis.generateAxisFromRange(0f, maxVal, 1f)
        yAxis.textSize = 8
        yAxis.setHasLines(true)

        val data = LineChartData()
        data.lines = lines
        data.axisYLeft = yAxis
        data.axisXBottom = xAxis

        aqcinChart.lineChartData = data
    }

    companion object {
        private const val NORMAL_CLOSURE_STATUS = 1000
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_chart)

        city = intent.getStringExtra("AQICity").toString()

        client = OkHttpClient()
        viewModel = ViewModelProvider(this).get(AqiViewModel::class.java)

        setupWebSocket()

        aqcinChart = findViewById<View>(R.id.aqcinChart) as LineChartView
        aqcinChart.isInteractive = true

    }

    private fun setupWebSocket() {
        val request = Request.Builder().url("ws://city-ws.herokuapp.com/").build()
        val listener: EchoWebSocketListener = EchoWebSocketListener()
        val ws = client!!.newWebSocket(request, listener)
        client!!.dispatcher().executorService().shutdown()
    }
}